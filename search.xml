<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《大话数据结构》要点整理]]></title>
    <url>%2F2020%2F11%2F23%2Fdata-structure%2F</url>
    <content type="text"><![CDATA[前言根据《大话数据结构》提取的一些书籍中的要点，根据自己习惯整理，可能对于他人不适用。整理了大部分要点，后续比较复杂的图结构和算法没有再深入整理。 绪论 数据 数据元素 数据项 逻辑结构 数据对象之间的相互关系 集合结构 线性结构 树形结构 图形结构 物理结构 数据的逻辑结构在计算机中的存储形式 顺序存储结构 链式存储结构 抽象数据类型 数据类型 原子类型 结构类型 算法 常见时间复杂度 常数阶 线性阶 平方阶 对数阶 nLogn阶 立方阶 指数阶 线性表 顺序存储结构 链式存储结构 单链表 静态链表 循环链表 双向链表 栈 顺序栈 两栈共享空间 链栈 队列 顺序队列 循环队列 链队列 串由零个或多个字符组成的有限序列，又名叫字符串 顺序存储 链式存储 匹配算法 朴素模式 KMP 树n(n&gt;=0)个结点的有限集 空树n=0 度 结点的度结点拥有的子树个数 树的度树内个结点的度的最大值 深度树中结点的最大层次（根为第一层） 结点关系 孩子 双亲 兄弟 祖先 子孙 子树是否固定次序 有序树 无序树 森林m(m&gt;=0)棵互不相交的树的集合 存储结构 双亲表示法 将每个结点顺序存储，每个结点需要记录下双亲结点的位置 看重不同的关系，例如兄弟关系，孩子关系等，可以在结点出记录下对应关系的结点位置 孩子表示法 结点孩子排列起来，以单链表作为存储结构；头指针组成线性表，顺序结构存储 孩子双亲表示法，在结点中添加双亲指针 孩子兄弟表示法 每个结点记录第一个孩子指针以及右边一个兄弟的指针 二叉树 特点 每个结点最多两棵子树 左右子树有次序 能区分左右子树 特殊二叉树 斜树 满二叉树 完全二叉树 性质 在二叉树的第i层上，至多有2^(i-1)个结点(i&gt;=1) 深度为k的二叉树至多有2^k-1个结点 对于任何一棵二叉树T，如果叶子结点数为n0，度为2的结点数为n1，则n0 = n2 + 1 具有n个结点的完全二叉树的深度为[log2,n] + 1 如果对一棵有n个结点的完全二叉树的结点按层序编号 存储结构 顺序存储结构 适合完全二叉树 不适合其他结点不规则的树，如左右斜树 二叉链表 遍历算法 前序遍历 中序遍历 后序遍历 线索二叉树 二叉树的线索化 没有左孩子，存放前序结点 没有右孩子，存放后继结点 遍历 按顺序找左结点或者右结点 树、森林与二叉树的转换 树转二叉树 森林转换二叉树 赫夫曼树 带权路径长度WPL最小的二叉树 构造 赫夫曼编码已知字符集和频率集，根据频率来构造赫夫曼树。规定左分支代表0，右分支代表1，则从根结点到叶子结点经过路径分支组成的0，1序列为对应编码 压缩和解压 图由顶点的有穷非空集合和顶点之间的边的集合组成，G(V, E)，G代表图，V代表顶点集合，E代表边集合 定义 无向边和无向图G=(V, {E})，E={(A,B)…} 有向边和有向图G=(V, {E})，E={&lt;A,B&gt;…} 简单图 不存在顶点到其自身的边 一条边不重复出现 无向完全图无向图中，任意两个顶点都存在边 有向完全图有向图中，任意两个顶点都存在边 网图的边或弧相关的数叫做权，带权的图 存储结构 矩阵 邻接矩阵（有向图） 对称矩阵（无向图） 表 邻接表（无向） 邻接表（有向） 十字链表 - 优点 - 结合了邻接表和逆邻接表，容易计算入度和出度 - 时间复杂度和邻接表相同 - 适合于有向图 邻接多重表 边集数组 遍历 深度优先遍历（DFS）原则上从顶点开始，只要不是重复的就沿着右手边走，走完一圈后，还有一些顶点没有遍历到，所以原路返回，在每一个点再检查是否有其他点没有走到，类似于树的前序遍历。核心思想也是递归原则。 广度优先遍历（BFS）从顶点开始，将顶点设置为第一层，和顶点相关的点设置为第二层，以此类推 最小生成树 普里姆算法从已到达点（如果没有，则只有顶点）中，选择一条权重最小且能到达一个新顶点的路径，这样选择出来的路径 克鲁斯卡尔算法 最短路径 迪杰特斯拉算法 佛洛依德算法*D[v][w] = min{ D[v][w] , D[v][k] + D[k][w] }]]></content>
      <categories>
        <category>Development</category>
      </categories>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《代码整洁之道》要点整理]]></title>
    <url>%2F2020%2F11%2F23%2Fclean-code%2F</url>
    <content type="text"><![CDATA[前言根据《代码整洁之道》提取的一些书籍中的要点，根据自己习惯整理，可能对于他人不适用。整理了大部分要点，关于代码重构和代码味道的部分没有整理，在读code smell的时候再整理这部分。 整洁代码 代码的不可替代性代码呈现了需求的细节，只有代码能够将需求明确到机器可以执行的程度 什么是糟糕的代码可能是因为赶时间，来不及做代码的重构，想要留到后面再做，导致代码越来越“混乱”。稍后等于用不（Later equals never） 糟糕代码的代价 后期无法清理 新人难以上手 生产力不断下降 整洁代码的特性 优雅（命名，不重复）读代码，能够让人愉悦，而不是眉头紧锁 效率（测试）尽量不浪费运算周期 完善错误处理在细节上花心思 只做好一件事（函数大小，不发散）每个函数、每个类和每个模块都应该全神贯注与一件事，不受四周细节的干扰和污染 可增补性 错误处理 使用异常 函数不返回null 参数不传递null 对象和数据结构 对象暴露行为，隐藏数据 数据结构暴露数据，没有明显的行为 格式 善用IDE格式化工具 团队规则统一 注释 注释不能美化代码 尽量用代码来阐述 可用的注释 法律信息 对意图的解释 警示 Todo注释 代码Doc 需要避免的注释 多余的注释 误导性注释 循规式注释 可以用函数或变量代替的注释 注释掉的代码 和当前代码没有联系的注释 函数 短小最大行数20 只做一件事函数应该做一件事，并且做好这件事。判断函数是否不止做了一件事，可以看是否还能拆出一个函数，而该函数不仅是重新诠释实现 switch语句尽量将switch语句埋到抽象工厂下面，用多态代替 使用描述性的名称 函数参数不要超过3个理解参数的成本，测试的成本 抽离Try/Catch代码块 结构化编程代码块应该有一个入口、一个出口 命名 名副其实如果名称需要注释来补充，那么它就不算名副其实 避免误导 有意义的区分如a作为域内变量，the用于函数参数 使用可搜索的名称 避免使用编码如接口需要加 I 前缀，成员变量加m_前缀 类名类名和对象名应该是名词或者名词短语，指代它代表的含义，不应该是动词 方法名方法名应该是动词或者动词短语，指代要做的事情 每个概念对应一个词 添加有意义的语境 单元测试 TDD三定律 在编写不能通过的单元测试前，不可编写生产代码 只可编写刚好无法通过的单元测试，不能编译也算不通过 只可编写刚好足以通过当前失败测试的生产代码 保持可读性 Given-When-Then的结构 每个测试只包含一个概念 F，I，R，S，T（Fast, Independent, Repeatable, Self-Validating, Timely） 类 短小避免出现supper class 单一权责原则 内聚 系统 工厂不关心其内部实现 依赖注入(DI) 优化决策 迭进 简单设计 运行所有测试 不可重复 表达意图 尽可能减少类和方法的数量 以上规则按其重要程度排列 并发 并发相关代码有自己的开发、修改和调优生命周期 开发相关代码有自己要对付的挑战，和并发相关代码不同，而且往往更为困难 并发防御原则 限制数据作用域 单一权责 使用数据副本 线程尽可能独立 执行模型 基础定义 限定资源 互斥 线程饥饿 死锁 活锁 生产者-消费者模型 读者-作者模型 宴席哲学家 测试 足够的测试 使用覆盖率工具 别略过小测试 被忽略的测试就是对不确定事物的疑问 测试边界条件 全面测试相近的缺陷 测试失败的模式有启发性 测试覆盖率的模式有启发性 测试应该快速]]></content>
      <categories>
        <category>Development</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thoughtworks的敏捷开发]]></title>
    <url>%2F2020%2F11%2F14%2Fthoughtworks-agile%2F</url>
    <content type="text"><![CDATA[三大支柱 经营可持续的业务(Run a sustainable business) 推动IT变革，追求软件卓越(Champion software excellence and revolutionize the IT industry) 积极提倡社会和经济公正(Advocate passionately for social and economic justice) 核心原则价值驱动什么是价值驱动 一种成效导向的、基于价值和反馈驱动来进行优先级排序的决策系统。这套系统是一个闭环，能够持续提供反馈并修正方向。首先建立起对愿景和目标的分解机制，并充分认识到每个投注的不确定性，通过尽量小的尝试来不断调整投资组合，保证对外界变化的快速响应。 为什么要做价值驱动 在如今的大环境下，我们很难将传统行业的投资管理的那一套方法和理论应用在软件开发行业中。因为软件开发充满了不确定性。用最少的力，验证当前设想的业务价值。 Story是什么 Story是开发团队的最小工作单元。User Story(用户故事)是业务需求的载体。一张合格的story应该包含一个完整的用户故事，通常以Given，When，Then的结构。翻译过来大概意思是：假设我（使用者）处于一个什么样的环境，当我（使用者）进行了什么操作，那么我（使用者）应该接受到什么样的反馈。 技术卓越核心实践基于统一迭代节奏的全功能团队]]></content>
  </entry>
  <entry>
    <title><![CDATA[在Gradle中添加Dependency Check，以及在Sonar中查看报告]]></title>
    <url>%2F2020%2F07%2F19%2FdependencyCheck%2F</url>
    <content type="text"><![CDATA[前言在项目中需要引入dependency check的工具来扫描相关依赖的库是否有安全漏洞等问题。由于是使用Gradle作为依赖构建工具，以及kotlin作为开发语言，所以选择了owasp dependency check的Gradle插件的方式。最后需要将报告上传到sonar进行展示。 工具 Gradle 6.4.1 org.owasp.dependencycheck sonarqube 流程引入依赖 在build.gradle.kts中添加相关的依赖： 12id("org.owasp.dependencycheck") version "5.3.2.1"id("org.sonarqube") version "2.6.2" 添加Sonar配置项在sonar的配置项中添加dependency check报告的路径： 12# dependency check reportingsystemProp.sonar.dependencyCheck.htmlReportPath=build/reports/dependency-check-report.html 添加Sonar的dependency check插件在sonar中选择Administration的tab，进入Marketplace。在Plugins中搜索并安装如图的插件： 添加Jenkins Task项目中使用了Jenkins作为CI构建工具，所以需要在其中添加一个stage用于将dependency check report上传到sonar中。如下： 1234567891011121314151617181920212223242526stage('DEPENDENCY CHECK') &#123; steps &#123; script &#123; def dependencyCheck = true try &#123; timeout(time: 20, unit: 'SECONDS') &#123; input 'Dependency Check?' &#125; &#125; catch(e) &#123; dependencyCheck = false &#125; if (dependencyCheck)&#123; sh './gradlew dependencyCheckAnalyze' &#125; &#125; &#125;&#125;stage('SONAR ANALYSIS') &#123; steps &#123; script &#123; sh './gradlew sonarqube -Dsonar.host.url=http://$&#123;HOST&#125;:9000 -Dsonar.login=$&#123;SONAR_CREDS&#125;' &#125; &#125;&#125; 由于dependency check并不是每次跑pipeline都需要，所以通过timeout+input的方式来手动run这一个stage。当跑完./gradlew dependencyCheckAnalyze后就会生成相关的report文档，默认是html格式，可以通过配置修改。 当dependency check跑完之后，就应该执行./gradlew sonarqube命令将本地report上传到sonarqube来分析。sonar的host.url和login参数既可以配置在sonar对应的properties，也可以在run命令的时候传入。这里是因为将creds配置到了Jenkins中，所以在Jenkins file中通过获取凭证的方式来配置。 成果当Jenkins CI跑完Sonar Analysis后，就可以去Sonar上查看对应的dependency check的report。如图]]></content>
  </entry>
  <entry>
    <title><![CDATA[记一次Inception]]></title>
    <url>%2F2020%2F07%2F03%2FInception%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[背景由于疫期影响，公司在短期内没有接到新的项目，于是就有近10多个小伙伴处于无项目状态。正好公司有一个idea是关于做一个shareable component，服务于以后的其他项目，减少一些集成时间，所以就召集了这些小伙伴来一起成立了这个Team。但是对于这个项目，需求并不明确，技术栈不好确定，让小伙伴们感觉无从下手。于是就由公司的BA带领，做了一次Inception，梳理相关的需求。 过程User Interview Prepare在决定做Inception后，我们就开始了对于用户调研的准备。关于目标用户，我们挑选了“已经集成过该功能”的项目组成员，以及“准备集成该功能”的项目组成员。从“已集成”的用户方可以了解到集成的痛点和经验，从“准备集成”的用户方可以了解到担心的点和功能的需求。 在做用户访谈的准备工作中，我们经过小组的“脑暴”方式，举出了很多和我们开发息息相关的问题，文档格式为： 访谈目标 用户分层 问题 备注 这次访谈的目标是什么，比如挖掘用户关于SC的使用需求和痛点 TL、Dev 可以分为用户的基本信息和访谈重点 该问题的回答对项目的实质帮助 当定好了用户问题列表以后，就需要和用户约定时间，发出邀请的calendar。在calendar中的人员应该包含：受访人，访谈人，记录者，以及对应的访谈地点。 User Interview在做用户访谈的过程中，需要双方做自我介绍，最好是访谈方先主动自我介绍，让对方放下戒备。在访谈的过程中，可能会出现用户关于问题的回答和我们预期的方向不一致，要及时介入，将话题重新引回到我们希望用户澄清的方向上。 用户在聊天过程中，可能会想到一些其他的idea。如果项目组觉得有价值，可以记录在备注栏中。用户访谈记录表可以参考： 问题 回复 备注 准备的问题 用户的回答内容 根据用户回答补充的内容 Pain Point &amp; Expectation通过将不同用户的访谈记录表整理起来，从中我们可以分析出用户的痛点与期望，格式类似于： 受访人 痛点 期望 备注 姓名 在访谈问题列表中关于当前现状的痛点 在访谈问题列表中关于产品的期望 访谈时整理的一些备注 Personas将不同分层后的用户的痛点与期望整理到一起，可以得出不同的用户画像。用户画像需要包含虚拟用户的姓名，职业，年龄，是否有相关背景等，以及对应的痛点和期望。 User Test在得到用户画像以后，需要进行受访人的回访，确认对应的用户画像是否和受访人的痛点与期望相同。在本次的Inception中，因为时间问题，省略掉了这一步。 Project Part Project visioning 在通过User Test后得到最终的用户画像后，就可以来定义产品愿景。产品的愿景是解决用户的痛点，满足用户的期望。可以通过电梯演讲的格式来梳理愿景，包含五个关键部分：FOR, OUR, IS, IT CAN, GOAL。 Project Roadmap Estimation for MVP Scope Planning Tech Part Tech solution Tech stack RADIs (Risk, Assumption, Issue, Dependency) Inception Showcase当准备好产品和技术的相关报告文档，就需要向客户约时间准备inception showcase的时间。Slide部分不需要展示详细信息，可以讲相关文档链接保留在slide上，在slide上展示的是产品特性和解决的痛点，以及相关的安排流程。在showcase中需要展示MVP的scope，以及对应的时间安排。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin协程]]></title>
    <url>%2F2020%2F05%2F19%2FKotlin%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Kotlin协程学习协程是什么在Kotlin官方文档上面描述——“本质上，协程是轻量级的线程”，在Kotlin中的协程也可以说是Kotlin提供的一套线程封装的API。 一个简单的示例： 1234launch(&#123; val user = APIService.getInstence().getUser() //请求网络数据 nameTv.text = user.name&#125;) 在上面的代码中，我们可以看到第2行中做了一个请求网络数据的耗时的I/O操作。通过协程的方式，我们可以将这样的一个异步操作写得看起来和同步操作无异。 基本使用示例中的launch函数并不是一个顶层函数，不能直接调用，需要被对象所调用。可以通过三种方法来创建协程： 123456789101112131415// 使用runBlocking顶层函数runBlocking&#123; getUserInfo(userId)&#125;// 使用GlobalScope对象GlobalScope.launch&#123; getUserInfo(userId)&#125;// 创建新的CoroutineScopeval coroutineScope = CoroutineScope(context)coroutineScope.launch&#123; getUserInfo(userId)&#125; 方法一适用于单元测试，因为runBlocking中的挂起方法以及调用层级会一直有效的阻塞当前线程 方法二不会阻塞当前显示，但是如果使用了GlobalScope，则该挂起方法的生命周期会和整个App一致，并且不能取消 在launch方法中可以传入context参数，该参数和Android中的context不是同一概念，我们可以使用Android平台封装好的context，如Dispatchers.IO，Dispatchers.Main，Dispatchers.Default，以及Dispatchers.Unconfined。在这里定义了对应的context，那么协程就会在该context上开启，比如在IO线程或者主线程中。 协程写法的好处如果有这样一个需求，我们需要在一个方法体内同时获取用户的头像以及公司的信息，我们使用callback可能会这样写： 1234567api.getAvatar(user.avatarUri)&#123; avatar -&gt; api.getCompanyLogo(user.id)&#123; logo -&gt; showMergeMessage(avatar, logo) &#125;&#125; 如果我们使用协程的写法： 12345coroutineScope.launch(Dispatchers.Main)&#123; val avatar = async &#123;api.getAvatar(user.avatarUri)&#125; val componyInfo = async &#123; api.getCompanyInfo(user.id) &#125; showMergeMessage(avatar.await(), componyInfo.await())&#125; 这样对比可以看出，即使是复杂的并行网络请求，通过协程写出来的代码结构会更加清晰。 协程的正确使用我们刚刚说过我们在launch方法中传入不同的context会决定该协程在哪个context上开启，那么刚才获取头像和公司信息的协程示例代码中，我们api请求应该需要放在IO线程中，而后面的showMergeMessage是需要将信息在页面上渲染，应该放在主线程中，类似于： 123456coroutineScope.launch(Dispatchers.IO)&#123; val avatar = getAvatar() launch(Dispatchers.Main)&#123; avatarIv.setImageBitmap(avatar) &#125;&#125; 这样的话看起来确实好理解一些，但是还是有嵌套的代码。这里需要提到另一个函数——withContext。这个函数可以做一件事情——切换到指定的线程，在闭包中的逻辑执行结束后，自动切换回到之前的线程。如果我们把withContext放到getAvatar方法中，那么写法就变回了之前同步的写法。 结尾文档内容是大部分引用于朱凯的关于协程的文章，做的一次学习总结。原文地址]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android网络请求]]></title>
    <url>%2F2020%2F05%2F18%2FAndroid%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[Android网络请求对于Android的网络请求有很多种用法，本文讨论的是kotlin协程+Retrofit2进行网络请求的处理。 通过阅读Retrofit的官方文档可以知道，首先我们需要定义service的接口，即请求的方式，参数，以及返回值。需要对方法使用suspend关键词进行包装，这里使用suspend关键词包装的原因是我们会在viewmodel中使用协程进行访问api的操作。 1@GET("/user/profile") suspend fun getUserProfile(): UserProfile 接下来我们需要构建Retrofit对象，使用官方推荐的okhttp client，定义相关的配置以及拦截器，这里推荐使用单例模式构建Retrofit对象。例如： 123456789val clientBuilder = OkHttpClient.Builder().connectTimeout(30, TimeUnit.SECONDS)clientBuilder.addInterceptor(AuthHeaderInterceptor(token))clientBuilder.addInterceptor(ErrorHandleInterceptor(context))Retrofit.Builder() .baseUrl(BASE_URL) .client(clientBuilder.build()) .addConverterFactory(GsonConverterFactory.create()) .build() .create(ApiService::class.java) 由于项目中将所有网络请求操作放在了viewmodel层进行，所以我们需要在viewmodel中使用viewModelScope.launch{}的方式来在viewmodel的scope中启动协程进行网络请求。这种方式可以避免使用callback的方式来处理请求结果，但是在错误处理方面比较弱，只能通过try，catch包裹来处理异常： 12345try &#123; val yachtDetail = ApiService.getInstance().getYachtById(yachtId)&#125;catch (e: Exception) &#123; Log.e("getYachtById", e.toString())&#125; 针对不同的error进行处理的时候可以考虑使用retrofit的Call对象，在定义的接口的时候如下： 1@GET("/yachts/&#123;id&#125;") fun getYachtById(@Path("id") yachtId: Long): Call&lt;YachtDetail&gt; 在调用接口处的地方可以传入callback进行处理： 123456789ApiService.getInstance().getYachtById(yachtId).enqueue(object :Callback&lt;YachtDetail&gt;&#123; override fun onFailure(call: Call&lt;YachtDetail&gt;, t: Throwable) &#123; TODO("Not yet implemented") &#125; override fun onResponse(call: Call&lt;YachtDetail&gt;, response: Response&lt;YachtDetail&gt;) &#123; TODO("Not yet implemented") // can do something by different response.code() &#125;&#125;)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>协程</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android表单处理]]></title>
    <url>%2F2020%2F05%2F17%2FAndroid%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android技术沉淀表单处理表单的处理在项目中会经常遇到，在我们POC项目中，也会涉及到处理用户信息的显示与更新，如图 5-1 所示。由于获取用户信息是异步操作，需要调用API，若此时用户在输入框中输入信息，当获取用户信 息的API访问完成，用户输入的信息就会被覆盖掉。为了防止此类问题出现，我们的解决方案是：在调用完获取用户信息API后，再显示表单，让用户可以进行更新信息的操作。若获取用户信息API调用失败，将会跳到Error界面。图 5 -1 表单的数据处理上，还会涉及到数据的双向绑定，及表单字段对应的数据模型会改变界面上显示的数据，界面上用户的输入会改变相应的数据模型。项目中使用到了Android自带的数据绑定库（databinding），可以通过两种方式实现数据模型与界面数据的状态更新： 方法1: 单向数据绑定+组件监听器： 在相应xml文件里的view加入单向数据绑定标识符号@以及数据名称，再在为输入框设置监听，来改变相应的数据模型。（如下图所示） 1234&lt;com.google.android.material.textfield.TextInputEditText android*:id="@+id/profile_edit_about_me_input" android:text="@&#123;userProfile.aboutMe&#125;" /&gt; 添加监听器 123binding.profileEditAboutMeInput.addTextChangedListener &#123; profileViewModel.userProfile.value.aboutMe = it.toString()&#125; 方法2: 双向数据绑定：在相应xml文件里的view加入双向数据绑定标识符@=以及数据名称，再为需要绑定的字段加上bindable修饰器（编译时，会自动生成相应字段的BR），配合notifyPropertyChanged即可完成双向绑定 ， 从而省去View层监听及setText调用的逻辑代码。 1234&lt;com.google.android.material.textfield.TextInputEditText android:id="@+id/profile_edit_about_me_input" android:text="@=&#123;userProfile.aboutMe&#125;"/&gt; 1234567class UserProfile( aboutMe: String?) : BaseObservable() &#123; @get:Bindable var aboutMe: String? = "" set(value) &#123; field = value notifyPropertyChanged(BR.aboutMe*) &#125; init &#123; this.aboutMe = aboutMe &#125;&#125; 由于项目中将表单字段封装到UserProfile类中，涉及到类中字段的自定义getter/setter，示例代码中方法2会比方法2多几行代码。但是如果涉及多个view内input feild对同一个字段的绑定，方法一则需要添加更多的监听器，而方法二只需要使用“@=”绑定上相应数据字段，即可实现自动同步view与数据模型。这样可以简化view层与数据模型同步的测试，挺高了可维护性。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人沉淀]]></title>
    <url>%2F2020%2F05%2F17%2F%E4%B8%AA%E4%BA%BA%E6%B2%89%E6%B7%80%2F</url>
    <content type="text"><![CDATA[个人沉淀]]></content>
  </entry>
  <entry>
    <title><![CDATA[Typescript学习]]></title>
    <url>%2F2019%2F07%2F24%2FTypescript%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[TypeScript概要 编译期行为 不改变运行时行为 不会引入额外的开销 契约高于实现 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102type A = &#123; a: string; b: number;&#125;;type B = &#123; c: string; d: number;&#125;;type C = A | B;type D = A &amp; B;const testD: C = &#123; a: "test", b: 2 &#125;;type Tuple = [number, string];const array: Tuple = [1, "2"];type Site = "samll" | "default" | "big"; // Settype MapB = &#123; small: string; default: number; big: string;&#125;; // Map// type map2Set = keyof MapB; // =&gt; small | default | bigtype map2Set = MapB[keyof MapB]; // =&gt; string | number | stringtype set2Map = &#123; [key in Site]: string;&#125;;// =&gt; type set2Map = &#123;// small: string,// default: string,// big: string// &#125;// map取索引值type MapTest = &#123; test: number;&#125;;type valueOfIndex = MapTest["test"]; // =&gt; numbertype Person = &#123; readonly name: string; age?: number;&#125;;const person: Person = &#123; name: "John"&#125;;// person.name = "test"; // =&gt; get the error//同态变换type PartialTest = Partial&lt;Person&gt;; ////set生成同类型的map(只能生成同类型)type SizeSet = "small" | "default" | "big";type SizeMap = Record&lt;SizeSet, number&gt;;// type SizeMap = &#123;// small: number,// default: number,// big: number// &#125;//类型递归type DeepReadOnly&lt;T&gt; = &#123; readonly [P in keyof T]: DeepReadOnly&lt;T[P]&gt;;&#125;;//readonly [P in keyof T]: [DeepReadOnly&lt;T[P]&gt;]type TestObject = &#123; a: &#123; b: &#123; c: number; &#125;; &#125;;&#125;;type DeepTypeMap = DeepReadOnly&lt;TestObject&gt;;const obj: DeepTypeMap = &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125;;// obj.a.b.c = 2; will get type errorinterface SomeProps &#123; a: string; b: number; c: (e: MouseEvent) =&gt; void; d: (e: TouchEvent) =&gt; void;&#125;// 如何得到 'c' | 'd' ？type GetFixedParams&lt;T, C&gt; = &#123; [P in keyof T]: T[P] extends C ? P : never;&#125;[keyof T];type TestObj = GetFixedParams&lt;SomeProps, Function&gt; // "c" | "d" 参考来源 https://juejin.im/post/5d4285ddf265da03dd3d514b?utm_source=gold_browser_extension#heading-15]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 学习]]></title>
    <url>%2F2019%2F07%2F10%2Flinux-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[相关系统 ubuntu redhat centOS 使用方向 企业服务器 嵌入式开发 特殊 区分大小写 一切皆文件 文件后缀名不重要 安装准备 VirtualBox centOS 镜像文件 设置镜像地址 iterm2 - ssh连接 本地网络设置 设置 /etc/sysconfig/network-scripts/ifcfg-enp0s3 中ONBOOT为yes 重启网络 service network restart SSH学习 服务器安装SSH服务 yum install openssh-server service sshd start chkconfig sshd on ssh连接服务器 1ssh &lt;username&gt;@&lt;IP address&gt; 配置ssh链接~/.ssh/config 文件中添加host &quot;&lt;name&gt;&quot; HostName &lt;IP address&gt; User &lt;username&gt; Port &lt;port&gt; 配置ssh密钥登陆~/.ssh/config/authorized_keys添加密钥 修改ssh服务器端口号/etc/ssh/sshd_config中在Port部分添加或者修改端口号 常用命令 软件操作命令 yum remove ~ yum serach ~ yum clean packages yum list yum info ~ 服务器硬件资源信息 内存 free -m 硬盘 df -h 负载 w/top 0.6～0.7是正常健康值 cpu个数 cat /proc/cupinfo 文件操作命令 mkdir -p test1/test2/test3 rm -rf test1 vim命令（菜鸟教程） dd 删除整行 gg 跳到文首 G 跳到文尾 u 撤销删除 yy 复制 p 粘贴 权限421 以二进制表示 如 rwxr-x--x则代表 (4+2+1) + (5) + (1) = 751 文件读取 head 从头部查看 tail 从尾部查看 more 分页查看 less grep 模糊查找 文件查找 find -name 名称（* 模糊搜索） find -type 类型（d, f） find -ctime 时间限制 文件压缩和解压 tar -cf 压缩文件 tar -tf 查看压缩文件内容 tar -xf 解压文件 tar -czf 压缩成gz格式 tar -xzf 解压gz文件 用户操作 adduser &lt;userName&gt; 添加用户 passwd &lt;userName&gt; 添加用户密码 userdel -r &lt;userName&gt; 删除用户以及相关文件夹 防火墙 firewall-cmd 命令行操作 提权操作 通过visudo 进入到文件编辑，找到其中## Allows people in group wheel to run all commands的部分，添加进相应的账号设置权限。 获取文件 wget curl 文件上传 scp &lt;filename&gt; &lt;ipaddr&gt;:&lt;path&gt; 文件下载 scp &lt;ipaddr&gt; &lt;filename&gt; &lt;downloadpath&gt; Apache yum install httpd 启动 service httpd start 安装 service httpd stop 结束 ps -ef | grep httpd 查看启动的httpd相关的服务 netstat -anpl |grep &#39;http&#39; 查看http开放端口 chown -R &lt;userName&gt;:&lt;userName&gt; &lt;dirPath&gt;将某个文件夹权限赋予某个用户 安装好以后可能通过浏览器无法访问，此时可以将linux防火墙关闭后再试 设置虚拟主机 首先进入/etc/httpd/conf文件夹中，vim编辑httpd.conf文件，添加 123456&lt;VirtualHost *:&lt;port&gt;&gt; ServerName &lt;serverName&gt; documentRoot &lt;documentRoot&gt; Options Indexes FollowSymLinks&lt;/VirtualHost&gt; 如果启动依旧报错，可以尝试运行setenforce 0，0为宽容模式，1为强制模式]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[墨菲定律]]></title>
    <url>%2F2019%2F06%2F27%2F%E5%A2%A8%E8%8F%B2%E5%AE%9A%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[镜中人人们对于自我的评价大部分来自于他人的观点，每个人的自我观，都是通过与别人的相互作用形成的。自我的概念似乎有这么三条原则：想象我们呈现给他人的外在；想象他人对我们呈现外在的评价，以及感知对这种评价的自我感觉，比如骄傲或者耻辱。 自我服务偏见表现为以下四类： 将成功归因于自己的能力和努力，将失败归因于运气和外在因素 与他人相比，认为自己更好 盲目的乐观主义 虚假普遍性和虚假独特性 我们更容易想起自己做过什么而往往很难想起自己没做过什么或者仅仅是看他人在做。当信息与我们的自我概念有关时，我们会对它进行快速的加工和很好的回忆，这叫“自我参照效应”。 而相应的应对策略则是“克制自己，顺应他人”。自己首先要意识到这种心性，尽量避免自我偏见。和他人的沟通交流中则是要允许他人拥有这种偏见，因为并不是任何人都能意识或者正视它，记住富兰克林说过：“如果你想要说服别人，要诉诸利益，而非诉诸理性。” 锚定效应含义为：用户对事物的认知，总会根据第一印象或信息形成一个自己对此事物的片面认知。就好像锚对于船只一样，用户会在自己的心里抛下一个对该事物的认知锚一样。 类似自己对于深圳的印象，自己只去深圳呆了不到一个月，以后提及关于深圳的印象就是空气湿度很大。第一印象就决定了我怎么来看待深圳这个城市。也许只是我去的那块区域恰好湿气比较大，或者是特殊的天气原因，但是也不能以第一印象去决定好坏是非。 在商业中总是会接触到一些商家利用锚定效应的行为，因为中国人很爱比较。价格相同比质量，质量相同比价格，双十一，618 等等活动层出不穷。 乔布斯说过：“我们的顾客不是要占便宜，而是要有一种占了便宜的感觉”，利用锚定效应可以很容易的让客户感觉到占便宜的心理。对于生活中的我们来说有两种方法解决： 抛弃以往观点，从头开始审视问题（较难） 吸收大量信息或者观点，自我整理后得出相对客观的结论 瓦伦达效应含义：人在做某一件事情时，总会联想到结果，并祈求一个好的结果；越在乎，越紧张，在这种心理机制下，无法释放自己，发挥自己的最佳状态，反而不利于事情的正面发展。 在紧张的心态和过分的渴望中无法自拔，对结果的关注超越了事件本身，于是便无法集中精力去尽心尽力地完成每一个细节，好好表现，也就离失败越近。专注于事情本身，专注于过程去追求成功，这是最好的应对；思考过度容易造成妄想，患得患失，没有好的心态去应对，反而容易失败。 压力越大，越是紧张，越是影响自身发挥，注重思考失败的后果，无法专注于事情。曾经因为比赛，紧张得一晚上睡不好觉，导致第二天白天无精打采，比赛表现也差强人意。值得对比的是第一次参加比赛的自己，抱着平和的心态，奋力一搏，目标专一。应对的做法大概如下： 放平心态，奋力一搏 不要太在乎结果的输赢，注重过程 感知到自我紧张的时候，调节心态]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript核心概念]]></title>
    <url>%2F2019%2F04%2F12%2FJavaScript%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[函数函数即是一种特殊的对象——函数对象，初始化一个Function如下： 12var funName = new Function( [argname1, [...argnameN]], body );var add = new Function( "x", "y", "retruen x + y" ); 通过new关键字创建了一个Function对象，和使用new String(&quot;test&quot;)创建String对象是一个道理。现在的语法糖，通过字面量来创建函数，如：12345678910111213function add(x, y) &#123; return x + y;&#125;const add = function(x, y) &#123; return x + y;&#125;const add = (x, y) =&gt; x + y;//这种Function创建方式的add没有prototype属性add.test = "test";console.log(add.test)//"test", 表明函数其实也是一种对象可以添加属性 原型对象拥有__proto__和constructor属性，__proto__属性表示的就是它的父原型，其中包含了父原型的所有属性，如果在当前对象中找不到某个属性，就会沿着原型链查找父原型中是否有某个属性，如果到了最上层（Object的上层是null）也找不到，则返回undefine。 函数是一种特殊对象，不仅拥有上述两种属性，还拥有一种prototype属性。在通过new创建一个类的实例对象的时候，prototype属性的成员都成为实例化对象的成员。 函数作用域JavaScript的函数是在局部作用域内运行的，在局部作用域内运行的函数可以访问外层的变量和函数。Javascript的作用域为词法作用域，其作用域是在定义时（词法分析时）就确定下来的，而并非在执行时确定，如： 1234567var str = "global";function test () &#123; console.log(str); var str = "local"; console.log(str);&#125;test();//undefine,"local" 词法分析结束后，构建作用域链的时候，会将函数内定义的str变量放入该链，因此在整个test函数内可见。 数组特性在JavaScript中，length并非只读属性，可以手动改变，如： 1234var array = [1,2,3,4,5]console.log(array.length)array.length = 3console.log(array)//5, [1,2,3] 手动减小length会使得数组部分元素变得不可用。 以字符串可以作为数组的下标，就采用访问JavaScript对象的属性的方式进行，但是数组本身的length属性不会发生变化，如： 1234567var stack = [];stack["first"] = "1";stack["second"] = 2;stack["third"] = new Date();console.log(stack.length);stack[0] = 1;console.log(stack.length);//0, 1 排序数组的sort方法不关注数组内容是数字还是字母，只会按照字母的字典顺序来进行排序，如： 123var array = [0, 1, 2, 3, 23, 12];array.sort();console.log(array);//0, 1, 12, 2, 23, 3 可以通过给sort传递一个函数对象，按照函数规则排序。 new 操作符在JavaScript中使用new操作符并不是直接新建一个函数对象，如： 1234567891011function Shape(type) &#123; this.type = type; this.calc = function() &#123; return `calc, $&#123;this.type&#125;` &#125;&#125;var triangle = new Shape("type");//类似var triangle = &#123;&#125;;Shape.apply(triangle, ["type"])//区别在于： triangle instanceof Shape ,false]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[元字符 \d匹配数字 \w匹配word（数字、字母、下划线） \s匹配white space（空格和tab） \b匹配单词的开始或结束 ^匹配字符串的开始 $匹配字符串的结束 .匹配任何字符​ 常用限定符 {n}重复n次 {n,}重复n次或更多次 {n,m}​重复n到m次 *匹配任意次（可以为0次） +匹配重复一次或者多次 \转义字符，e.g. ​ .，*，\​​ ?重复零次或一次​ |分枝条件​ ()​分组 反义字符 \W匹配非word \S匹配非whie space​​ \D匹配非数字 \B匹配不是单词开头或结束的位置 [^aeiou]匹配除了aeiou字母以外的任意字符 简单例子 \ba\w*\b匹配以字母a开头的单词 \b0\d{2}-\d{8}匹配0开头格式为 0-*** 其中*为数字 ^\d{5,12}$​匹配5～12位数字 (?0\d{2}[) -]*\d{3}匹配 000-1234, (000)-1234, 000 1234 \d{3}-\d{4}|(\d{3}) \d{4}匹配000-1234, (000) 1234 (\d{1,3}.){3}\d{1,3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字 &lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串 复杂用法 捕获 (exp)匹配exp，并捕获文本放到自动命名组 (?exp)匹配exp，并捕获文本放到name组 (?:exp)匹配exp，不捕获文本，也不分组号​ 零宽断言 (?=exp)断言自身出现的位置的后面能匹配表达式exp (?&lt;=exp)断言自身出现的位置的前面能匹配表达式exp 负向零宽断言 (?!exp)断言此位置的后面不能匹配表达式exp (?&lt;!exp)断言此位置的前面不能匹配表达式exp 贪婪与懒惰 *?重复任意次，但尽可能少重复 +?重复1次或更多次，但尽可能少重复 ??重复0次或1次，但尽可能少重复 {n,m}?重复n到m次，但尽可能少重复 `{n,}?重复n次以上，但尽可能少重复 示例 \b(?\w+)\b\s+\k可以用来匹配重复的单词，e.g. test test -&gt; test test \b\w+(?=er\b)匹配以er结尾的单词除去er的部分，e.g. I’m a singer -&gt; sing​ (?&lt;=\bt)\w+\b匹配以t开头的单词除去t的部分，e.g. I’m try to exercise my English -&gt; ry o \d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字 (?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字 (?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容 e.g. test -&gt; test 2[0-4]\d(?#200-249)|250-5|[01]?\d\d?(?#0-199){带注释的匹配项 点击查看幕布详情]]></content>
  </entry>
  <entry>
    <title><![CDATA[React Hooks详解]]></title>
    <url>%2F2019%2F03%2F12%2FReact-Hooks%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[为什么要做 在组件中很难复用逻辑 在平常的开发中，复用逻辑都是通过 provider,consumer,higher-order,renderProps,and other abstractions” 等方式的应用。在hooks中，可以在不改变层级结构的前提下，你可以从组件中提取带状态的逻辑，因此可以更容易测试和复用。 复杂的组件变得很难理解 组件可能在componentdidmount和componentdiddupdate中执行一些数据提取。但是，相同的componentDidMount方法也可能包含一些设置事件侦听器的不相关逻辑，在componentWillUnmount中执行清理。hooks允许您根据相关的部分（例如设置订阅或获取数据）将一个组件拆分为较小的函数。 classes让人和机器变得混淆 在JavaScript中this关键字比较让人迷惑，必须记住bind事件的监听。hooks可以让你在不使用classes的前提下使用更多React的特性。 hooks使用 useState 等效于state用法，简单todoList实现： 12345678910111213141516171819202122232425import React, &#123;useState&#125; from 'react';const TodoList = () =&gt; &#123; const [todo, setTodo] = useState(""); const [todoList, setTodoList] = useState(["test"]); return ( &lt;div&gt; &#123;todoList.map((todo) =&gt; ( &lt;div&gt; &lt;div&gt;&#123;todo&#125;&lt;/div&gt; &lt;/div&gt; ))&#125; &lt;input type="text" value=&#123;todo&#125; onChange=&#123;(event) =&gt; &#123; setTodo(event.target.value); &#125;&#125;/&gt; &lt;button onClick=&#123;() =&gt; &#123; setTodoList([...todoList, todo]); setTodo(""); &#125;&#125;&gt;Add Todo &lt;/button&gt; &lt;/div&gt; );&#125;;export default TodoList; useState原理 初始化 创建两个数组：state和setters， 光标位置置为0 第一次渲染 调用useState时，第一次渲染，会将一个set函数放入setters数组中，并且把初始state放入到state数组中 后续渲染 每一次重新渲染，光标都会重新设为0，然后从对应的数组中读取状态和set函数 事件处理 每次调用set 函数，set函数将会修改state数组中对应的状态值，这种对应的关系是通过cursor光标来确定的 useEffect 在react类中，通常会在componentdidmount中设置订阅，并在componentwillunmount中清理订阅。这种模式在hoos下面的写法则是这样： 12345678910111213141516171819202122import React, &#123; useState, useEffect &#125; from "React";function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); // Specify how to clean up after this effect: return function cleanup() &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return "Loading"; &#125; return isOnline ? "Online" : "Offline";&#125; useEffect须知： useEffect方法中return的返回值就是我们在componentWillUnmout中执行的清理方法，也可以不返回。如果有两个方法在不同的生命周期行为不一致，如一个在componentDidMount时运行，另一个则update也要运行，可以使用两次useEffect方法。React按照指定的顺序运行useEffect方法。 useEffect性能优化： 在classes中，通过比较prevProps和provState来解决无用的重复渲染，在useEffect Hook API中则可以将数组作为可选的第二个参数，如： 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // 只当count改变的时候回再次运行这个效果 注意：如果这里给一个空数组，代表effect内部的prop和state的值不会修改，所以不会再次执行，类比componentDidMount和componentWillUnmount。但是这样不安全，因为无法记住effect外部的函数使用了哪些props或者state。因此通常在useEffect里面声明相关的函数，同样可以使用exhaustive-deps来检查。 * **useContext** 1const context = useContext(context); 接收一个context的对象（React.createContext创建的值），并且返回一个由最近的context provider的context value。当Provider更新时，这里的context会变为最新的值。 useReducer useReducer可以替代setState，如果对redux比较熟悉，则useReducer的用法就比较容易理解。特别是在当有涉及多个子值的复杂状态逻辑，或者下一个状态依赖于前一个状态时。引用官方示例： 1234567891011121314151617181920212223const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case 'increment': return &#123;count: state.count + 1&#125;; case 'decrement': return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;function Counter(&#123;initialState&#125;) &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; useMemo 用于记录某个函数执行结果后的值，如果该值的依赖参数无变化，则后续返回上一次计算结果。会在渲染阶段执行，所以不要执行和渲染无关的操作，比如副作用方法。如果不提供依赖项，则会在每次渲染的时候执行计算。 useCallback 接收一个回调函数和依赖数组，当依赖数组中的元素发生变化则重新生成新的function instance，当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染的子组件时，它将非常有用。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>React Hook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JWT概念-思维导图]]></title>
    <url>%2F2019%2F03%2F07%2FJWT%E6%A6%82%E5%BF%B5-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[单词本]]></title>
    <url>%2F2019%2F03%2F07%2F%E5%8D%95%E8%AF%8D%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[E代表出去的意思 exit n. 出口，通道；退场 escape vt. 逃避，避开，避免；被忘掉；被忽视 east n. 东方；东风；东方国家 excel (excellent) vt. 超过；擅长 exceed vt. 超过；胜过 expose vt. 揭露，揭发；使曝光；显示 effect n. 影响；效果；作用; vt. 产生；达到目的 educate vt. 教育；培养；训练 electricity n. 电力；电流；强烈的紧张情绪 ecstacy 喜出望外 代表用力、使的意思 enforce vt. 实施，执行；强迫，强制 enlarge vi. 扩大；放大；详述(widen vt. 放宽) enslave vt. 束缚；征服；使某人成为奴隶 empower vt. 授权，允许；使能够 strengthen vt. 加强；巩固 enable vt. 使能够，使成为可能；授予权利或方法 engage vt. 吸引，占用；使参加；雇佣；使订婚；预定; vi. 从事；参与；答应，保证；交战；啮合 enhance vt. 提高；加强；增加 encircle vt. 包围；围绕；环绕 enclose vt. 围绕；装入；放入封套 J代表扔、甩的意思 Jet (n. 喷射，喷嘴；喷气式飞机；黑玉) Inject (vt. 注入；注射) - in 里面 Project (投射、设计、项目) - pre 提前 Eject (vt. 喷射；驱逐，逐出) - e 出去 Reject (vt. 拒绝；排斥；抵制；丢弃) - re 反方向的 Interject (vt. 插入；干涉；插嘴) - inter 从中间 Object (vi. 反对；拒绝) - ob 客观 Objective (adj. 客观的；目标的；宾格的) Subject (n. 主题；科目；[语] 主语；国民, vt. 使…隶属；使屈从于…) - sub 主观 代表投票、正义的意思 Just (adj. 公正的，合理的；正直的，正义的；正确的；公平的；应得的) Judge (vt. 判断；审判, n. 法官；裁判员) Justice (n. 司法，法律制裁；正义；法官，审判员) Unjust (adj. 不公平的，不公正的；非正义的) Jury (n. [法] 陪审团；评判委员会) L代表线条 loop vi. 打环；翻筋斗 liner n. 航线，班机；衬垫；画线者 lure n. 诱惑；饵；诱惑物 leak n. 泄漏；漏洞，裂缝 lip n. 嘴唇；边缘 longing for 期待 lace n. 花边；鞋带；饰带；少量烈酒 lane n. 小巷；[航][水运] 航线；车道；罚球区 代表文化、说的意思 literate adj. 受过教育的；精通文学的(literature n.文学) lecture n. 演讲内容 allege vt. 宣称，断言；提出…作为理由 dialect n. 方言，土话；同源语；行话；个人用语特征 elect adj. 选出的；当选的；卓越的 legend n. 传奇；说明；图例；刻印文字]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逻辑英语]]></title>
    <url>%2F2019%2F03%2F07%2F%E9%80%BB%E8%BE%91%E8%8B%B1%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[基本的逻辑中文中基本的逻辑：(状) 主 (定) 谓 (状) (宾) (定/状)英语的基本逻辑是：(状语/定语) 主 (状) 谓 (定) (宾) (状) 主谓宾的定位 主语通常是位于句首的第一个名词，句首的独立名词性结构（名词、代词、分词、从句） 谓语（排除下列动词） 从句和介词短语中的动词 主语前的动词 分词前无助词的动词 谓语可以是动词词组 宾语 谓语后的独立名词 宾语可以没有（句=主+谓） 长状语或定语倒序规则简单的句子，只需要将状语或者定语放在主语宾语或者谓语后面，倒着排列，例如：The method of scientific investigation is basiclly nothing but the expression of the necessary mode of working of the human mind in practice. 长状语或定语并列不变序当从句或者定语中出现了并列关系，比如and，between，or等并列关系的词语，则里面的从句并列不变序，如从句1，2，3，4，5中，12和345之间出现了and连接，则规则是21,543，两句不变序，但是居中变序，例如：A man without passion and ideas at work will not make any progress. In your life, a man who helps you when you are in trouble and leaves you when you are successful is a real friend. 数量问题：是否可数可数和不可数是判断是否有固定的量化单位，如water，可以a cup of water、A bottle of water、A pot of water，没有固定的量化单位。但是比如coffee, a coffee就代表一杯咖啡，咖啡通常都是一杯一杯的。 就近就远原则就远（和公式相关，寻找真正的主语）： A woman with two children is coming. I as well as they am ready to help you 就近（重心原则）： Not only I but also he is right. 符号的确定, --, ;只可能是插入语和并列的表现形式。两个 ,之间可能是插入语，可能是并列关系。 长定语的处理在任何一个短语和下一个短语之间分割成两部分，以这 + 前词来组合翻译。]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>逻辑英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS水平居中]]></title>
    <url>%2F2019%2F03%2F07%2FCSS%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[设置height使其居中 给父布局的View设置一个定高，给其再设置一个与高度相同的行高（只使用于子组件占一行） 设置align-items属性 给其父布局设置display : flex后，再添加一个align-items : center属性]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript时间处理]]></title>
    <url>%2F2018%2F10%2F11%2FJavaScript%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[相关概念时区在地球上不同地方的人看到太阳升起的时间不一致，就有了时区的概念。例如北京早上8:00可以看到太阳刚刚升起，而欧洲此时还在夜晚，大概是凌晨1:00。他们看到当天太阳升起的时间应该是北京时间的下午3点，所以就有下面这样一个等式：1"2014-10-14 08:00 +8:00" = "2014-10-14 01:00 +1:00" 标准时间GMT即格林威治标准时间，指英国伦敦郊区的皇家格林威治天文台的标准时间，因为本初子午线被定位为通过此地的经线。由于地球不规则自转，导致GMT时间有误差，因此目前已不被当作标准时间使用。UTC是最主要的世界时间标准，是经过平均太阳时(以格林威治时间GMT为准)、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间。UTC比GMT来得更加精准。其误差值必须保持在0.9秒以内，若大于0.9秒则由位于巴黎的国际地球自转事务中央局发布闰秒，使UTC与地球自转周期一致。不过日常使用中，GMT与UTC的功能与精确度是没有差别的。协调世界时区会使用“Z”来表示。而在航空上，所有使用的时间划一规定是协调世界时。 TimeZone&amp;UTC Offsets:时区与偏移人们经常会把时区与UTC偏移量搞混，UTC偏移量代表了某个具体的时间值与UTC时间之间的差异，通常用HH:mm形式表述。而TimeZone则表示某个地理区域，某个TimeZone中往往会包含多个偏移量，而多个时区可能在一年的某些时间有相同的偏移量。譬如America/Chicago, America/Denver, 以及 America/Belize在一年中不同的时间都会包含 -06:00 这个偏移。 时间戳Unix时间戳表示当前时间到1970年1月1日00:00:00 UTC对应的秒数。注意，JavaScript内的时间戳指的是当前时间到1970年1月1日00:00:00 UTC对应的毫秒数，和unix时间戳不是一个概念，后者表示秒数，差了1000倍。 时间数字字符串格式RFC28221YYYY/MM/DD HH:MM:SS ± timezone(时区用4位数字表示) ISO 8601（国际标准）1YYYY-MM-DDThh:mm:ss ± timezone(时区用HH:MM表示) 常见时间使用问题服务器部署地不一致如果使用的是带时区的字符串转换的Moment对象，服务器部署地不一致时可能会导致某些测试failed。比如： 123451997-07-16T08:20:30Z// “Z”表示UTC标准时区，即"00:00",所以这里表示零时区的`1997年7月16日08时20分30秒`//转换成位于东八区的北京时间则为`1997年7月16日16时20分30秒`1997-07-16T19:20:30+01:00// 表示东一区的1997年7月16日19时20秒30分，转换成UTC标准时间的话是1997-07-16T18:20:30Z 如果有一个界面的snapshot测试，并且界面显示为日期和时间的字符串，在不同的服务器上运行就会导致界面不一致，从而影响测试。解决方法是使用不带时区的mockData去测试。值得注意的是在使用不带时区的字符串时，转换出来的是当地时间，当转换为时间戳时，不同地区的时间戳也不一样，所以使用时应该注意。]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack概念整理]]></title>
    <url>%2F2018%2F09%2F26%2Fwebpack%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[概念webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 入口 Entry指示webpack应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack会找出有哪些模块和库是入口起点依赖的； 123module.exports = &#123; entry: './path/to/my/entry/file.js'&#125;; 可以向entry传入一个数组，将会创建多个主入口。在想要将多个依赖文件一起注入，并且将依赖导向到一个chunk时就很有用，比如分离应用程序和第三方库入口。 123456const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;; 多页面应用程序 1234567const config = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125;; 出口 outputoutput属性告诉webpack在哪里输出所创建的bundles，以及如何命名这些文件，默认值为”./dist”。基本上，整个应用程序结构，都会被编译到指定的输出路径的文件夹中； 123456789const path = require('path');module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;&#125;; CDN和资源hash的复杂示例 1234output: &#123; path: "/home/proj/cdn/assets/[hash]", publicPath: "http://cdn.example.com/assets/[hash]/"&#125; 这里hash代表文件名为hash值，每次部署会比对hash值，当值不同时，会加载最新的文件。 加载器 loaderloader让webpack处理非JavaScript文件。loader可以将所有类型的文件转换为webpack能够处理的有效模版。 1234567891011121314const path = require('path');const config = &#123; output: &#123; filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: 'raw-loader' &#125; ] &#125;&#125;;module.exports = config; loader有两个属性： test 属性，用于表示应该被对应loader进行转换的某个或某些文件，可以模糊匹配； use 属性，表示进行转换时，应该使用哪个loader。 配置123456789101112131415161718```jsmodule: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: &apos;style-loader&apos; &#125;, &#123; loader: &apos;css-loader&apos;, options: &#123; modules: true &#125; &#125; ] &#125; ] &#125; 特性 loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照相反的顺序执行。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。 loader 可以是同步的，也可以是异步的。 loader 运行在 Node.js 中，并且能够执行任何可能的操作。 loader 接收查询参数。用于对 loader 传递配置。 loader 也能够使用 options 对象进行配置。 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。 插件(plugin)可以为 loader 带来更多特性。 loader 能够产生额外的任意文件。 插件 Plugins插件可以用于执行范围更广的任务。插件范围包括，从打包优化和压缩，一直到重新定义环境中的变量。想要使用插件，需要require()它，然后添加到plugins数组中，多数插件可以通过选项(option)自定义。可以通过使用new操作符来创建它的实例。 123456789101112131415const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const config = &#123; module: &#123; rules: [ &#123; test: /\.txt$/, use: 'raw-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config; 模式 module通过选择development或production之中的一个，来设置mode参数，可以启用相应模式下的内置优化。 123module.exports = &#123; mode: 'production'&#125;; 配置使用不同语言进行配置TypeScript首先使用相关依赖： 1npm install --save-dev typescript ts-node @types/node @types/webpack 使用的webpack.config.ts: 12345678910111213import path from 'path';import webpack from 'webpack';const config: webpack.Configuration = &#123; mode: 'production', entry: './foo.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'foo.bundle.js' &#125;&#125;;export default config; Webpack中的解析规则使用enhanced-resolve，webpack能够解析三种文件路径： 绝对路径123import "/home/me/file";import "C:\\Users\\me\\file"; 绝对路径不需要进一步解析。 相对路径12import "../src/file1";import "./file2"; 使用import或require的资源文件所在的目录会认为是上下文目录，在其中给定的相对路径会添加此上下文路径，产生模块的绝对路径。 模块路径12import "module";import "module/lib/file"; 模块会在resolve.modules中指定的所有目录中搜索。 多种配置类型导出为一个函数作为导出一个配置对象的替代，可以从webpack配置文件中导出一个函数。该函数在调用时，可以传入两个参数： 环境对象作为第一个参数。一个选项map对象(argv)作为第二个参数，这个对象描述了传递给webpack的选项，并且具有output-filename和optimize-minimize等key。 123456789101112-module.exports = &#123;+module.exports = function(env, argv) &#123;+ return &#123;+ mode: env.production ? 'production' : 'development',+ devtool: env.production ? 'source-maps' : 'eval', plugins: [ new webpack.optimize.UglifyJsPlugin(&#123;+ compress: argv['optimize-minimize'] // 只有传入 -p 或 --optimize-minimize &#125;) ]+ &#125;;&#125;; 导出一个Promisewebpack将运行由配置文件导出的函数，并且Promise返回。便于需要一部加载所需的配置变量。 12345678910module.exports = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; entry: './app.js', /* ... */ &#125;) &#125;, 5000) &#125;)&#125; 导出多个配置对象对于针对多个构建目标，打包一个library非常有用。 123456789101112131415module.exports = [&#123; output: &#123; filename: './dist-amd.js', libraryTarget: 'amd' &#125;, entry: './app.js', mode: 'production',&#125;, &#123; output: &#123; filename: './dist-commonjs.js', libraryTarget: 'commonjs' &#125;, entry: './app.js', mode: 'production',&#125;] DefinePlugin插件允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用。 用法每个传进 DefinePlugin 的键值都是一个标志符或者多个用 . 连接起来的标志符。 如果这个值是一个字符串，它会被当作一个代码片段来使用。 如果这个值不是字符串，它会被转化为字符串(包括函数)。 如果这个值是一个对象，它所有的 key 会被同样的方式定义。 如果在一个 key 前面加了 typeof,它会被定义为 typeof 调用 如: 1234567new webpack.DefinePlugin(&#123; PRODUCTION: JSON.stringify(true), VERSION: JSON.stringify('5fa3b9'),//变量 BROWSER_SUPPORTS_HTML5: true, TWO: '1+1',//当做代码片段 'typeof window': JSON.stringify('object')&#125;); Feature Flags（Feature Toggle）用来标记启用/禁用 生产/开发 构建中的功能。 1234new webpack.DefinePlugin(&#123; 'NICE_FEATURE': JSON.stringify(true), 'EXPERIMENTAL_FEATURE': JSON.stringify(false)&#125;); Process-进程该对象是一个全局变量，它提供当前Node.js 进程的有关信息，以及控制当前 Node.js 进程。 因为是全局变量，所以无需使用 require()。process.env属性返回一个包含用户环境信息的对象，可以对这个对象进行操作。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中Promise记录]]></title>
    <url>%2F2018%2F09%2F11%2FJavaScript%E4%B8%ADPromise%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[简介JavaScript中都是单线程执行，导致所有的网络操作，浏览器操作都必须异步执行。Promise异步执行时回调函数可以链式条用，Promise有各种开源实现，ES6中被统一规范，由浏览器直接支持。 用法简单示例：1234567891011121314function test(resolve, reject) &#123; var timeOut = Math.random() * 2; log('set timeout to: ' + timeOut + ' seconds.'); setTimeout(function () &#123; if (timeOut &lt; 1) &#123; log('call resolve()...'); resolve('200 OK'); &#125; else &#123; log('call reject()...'); reject('timeout in ' + timeOut + ' seconds.'); &#125; &#125;, timeOut * 1000);&#125; 在方法中有resolve和reject两个方法，如果执行成功，则调用resolve()，执行失败调用reject()，函数只关心自身逻辑，不关心具体的resolve和reject方法。 生成Promise对象： 12345new Promise(test).then(function (result) &#123; console.log('成功：' + result);&#125;).catch(function (reason) &#123; console.log('失败：' + reason);&#125;); Promise处理流程 串行执行1job1.then(job2).then(job3).catch(handleError); 异步执行多个任务12345678910var p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1');&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, 'P2');&#125;);// 同时执行p1和p2，并在它们都完成后执行then:Promise.all([p1, p2]).then(function (results) &#123; console.log(results); // 获得一个Array: ['P1', 'P2']&#125;); 多个任务获取先返回的结果123456789var p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1');&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, 'P2');&#125;);Promise.race([p1, p2]).then(function (result) &#123; console.log(result); // 'P1'&#125;); 由于p1执行较快，Promise的then()将获得结果&#39;P1&#39;。p2仍在继续执行，但执行结果将被丢弃。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios简介]]></title>
    <url>%2F2018%2F09%2F09%2FAxios%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[安装1$ npm install axios 1$ bower install axios CDN配置1&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; 示例 GET示例 1234567891011121314151617181920212223242526272829303132333435363738394041const axios = require('axios');// Make a request for a user with a given IDaxios.get('/user?ID=12345') .then(function (response) &#123; // handle success console.log(response); &#125;) .catch(function (error) &#123; // handle error console.log(error); &#125;) .then(function () &#123; // always executed &#125;);// Optionally the request above could also be done asaxios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;) .then(function () &#123; // always executed &#125;); // Want to use async/await? Add the `async` keyword to your outer function/method.async function getUser() &#123; try &#123; const response = await axios.get('/user?ID=12345'); console.log(response); &#125; catch (error) &#123; console.error(error); &#125;&#125; POST示例 12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 多个请求示例 123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // Both requests are now complete &#125;)); 更多相关示例可以查看官网：https://github.com/axios/axios]]></content>
  </entry>
  <entry>
    <title><![CDATA[MomentJS库笔记]]></title>
    <url>%2F2018%2F09%2F06%2FMomentJS%E5%BA%93%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[依赖123456npm install moment --save # npmyarn add moment # YarnInstall-Package Moment.js # NuGetspm install moment --save # spmmeteor add momentjs:moment # meteorbower install moment --save # bower (deprecated) 官网地址:http://momentjs.com/ 使用 日期格式化 12345moment().format('MMMM Do YYYY, h:mm:ss a'); // 九月 6日 2018, 10:21:36 晚上moment().format('dddd'); // 星期四moment().format("MMM Do YY"); // 9月 6日 18moment().format('YYYY [escaped] YYYY'); // 2018 escaped 2018moment().format(); // 2018-09-06T22:21:36+08:00 相对时间 12345moment("20111031", "YYYYMMDD").fromNow(); // 7 年前moment("20120620", "YYYYMMDD").fromNow(); // 6 年前moment().startOf('day').fromNow(); // 1 天前moment().endOf('day').fromNow(); // 2 小时内moment().startOf('hour').fromNow(); // 22 分钟前 日历时间 12345678moment().subtract(10, 'days').calendar(); // 2018年8月27日moment().subtract(6, 'days').calendar(); // 上周五晚上10点22moment().subtract(3, 'days').calendar(); // 本周一晚上10点22moment().subtract(1, 'days').calendar(); // 昨天晚上10点22分moment().calendar(); // 今天晚上10点22分moment().add(1, 'days').calendar(); // 明天晚上10点22分moment().add(3, 'days').calendar(); // 本周日晚上10点22moment().add(10, 'days').calendar(); // 2018年9月16日 多语言支持 12345678moment().format('L'); // 2018-09-06moment().format('l'); // 2018-09-06moment().format('LL'); // 2018年9月6日moment().format('ll'); // 2018年9月6日moment().format('LLL'); // 2018年9月6日晚上10点22分moment().format('lll'); // 2018年9月6日晚上10点22分moment().format('LLLL'); // 2018年9月6日星期四晚上10点22分moment().format('llll'); // 2018年9月6日星期四晚上10点22分 注意在snapshot测试中，使用moment(“2018-01-01T00:00:00.000Z”)时，本地测试通过，服务器pipeline跑测试可能会fail,原因是服务器可能和local不是同一个时区，当没有字符串最后的字母时，代表是一个固定时间。相反的是，使用moment(“2018-01-01T00:00:00.000”).unix()生成时间戳时，必须要最后的字母确定时区，才能准确获得唯一的时间戳。]]></content>
  </entry>
  <entry>
    <title><![CDATA[React使用Snapshot测试]]></title>
    <url>%2F2018%2F09%2F05%2FReact%E4%BD%BF%E7%94%A8Snapshot%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[原理快照测试在第一次运行时将在React组件不同情况下的渲染结果保存一份快找文件，以后运行测试时，都会和第一次的比较，可以达到像素级别的匹配校验。 方法创建一个命名为 tests 的文件夹，在其中添加以ComponentName.test.js命名的测试文件，如： 123456it("sightings renders correctly", () =&gt; &#123; const testRenderer = TestRenderer.create(&lt;Component /&gt;); //可选择性传入props expect(testRenderer.toJSON()).toMatchSnapshot();&#125;); 控制台下执行npm test方法，会自动在 tests 文件夹下生成 snapshots 文件夹以及一个.snap结尾的快照文件，这就是之后运行测试时会进行校验的快照文件。 当我们修改影响了Component组件样式后，snapshot测试会提示失败，需要控制台使用npm test – -u更新快照文件。]]></content>
  </entry>
  <entry>
    <title><![CDATA[重构——代码中的坏味道]]></title>
    <url>%2F2018%2F09%2F03%2F%E9%87%8D%E6%9E%84%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93%2F</url>
    <content type="text"><![CDATA[Duplicated Code（重复代码） 同一个类的两个及多个函数含有相同的表达式 采用Extract Method提炼出重复代码，让其他函数调用被提炼的那一段代码。 两个互为兄弟的子类内含相同表达式 对两个类使用Extract Method，然后对被提炼出来的方法使用Pull Up Method，将它推入超类。 两个毫无相关的类出现重复代码 对其中一个使用Extract Class，将重复代码提炼到一个独立类中，然后在另一个类中使用这个新类。 Long Method（过长函数）最终效果：每当感觉需要注释说明的时候，就应该把需要说明的东西写进一个函数，并用其用途来命名。 正常情况下，使用Extract Method就可以直接提炼某一块函数。如果函数含有大量的参数和临时变量，首先运用Replace Temp With Query消除临时变量，Introduce Parameter Object和Preserve Whole Object可以将过长的参数列表变得简单。 Long Method（过长函数）最终效果：每当感觉需要注释说明的时候，就应该把需要说明的东西写进一个函数，并用其用途来命名。 正常情况下，使用Extract Method就可以直接提炼某一块函数。如果函数含有大量的参数和临时变量，首先运用Replace Temp With Query消除临时变量，Introduce Parameter Object和Preserve Whole Object可以将过长的参数列表变得简单。 Large Class（过大的类）如果想利用单个类做太多事情，其中就会出现很多实例变量，往往导致Duplicate Code出现。使用Extract Class将几个变量提炼至新类。 先确定客户端如何使用它们，然后运用Extract Interface为每一种使用方式提炼出一个接口，有利于清楚的知道如何分解这个类。 Long Parameter List（过长参数列）函数需要太多参数会造成前后不一致，不易使用，而且一旦需要更多数据，就不得不修改它。如果向已有对象发出一条请求就可以取代一个参数，可以运用Replace Parameter with Method方法。 Divergent Change（发散式变化）如果某个类经常因为不同的原因在不同的方向上发生变化，比如，替换某一个工具类，需要在一个类的好几处函数中修改。针对某一外界变化的所有相应修改，都应该只发生在单一类中，而这个类中的所有内容都应该反应这个变化。 Switch Statements何时该用switch，何时该用多态。如果在单一函数下有些选择示例，就可以继续使用switch。如果在多个地方需要同样的switch语句时就需要修改为多态来解决问题。 Temporary Field（令人迷惑的暂时字段）某个实例变量仅为某种特殊情况而定，这样的代码让人不易理解。有些字段只在使用该函数时生效，其他情况下只会让人迷惑。利用Extract Class把相关变量和相关函数提炼到一个独立类中。 Comments（过多的注释）通常会有这种情况：看到一段代码有着常常的注释，是对某段复杂代码加以解释，之所以存在原因是因为代码很糟糕。当看到注释时，第一反应应该是能否用重构去除代码复杂性。 Data Class（纯稚的数据类）只是一个数据容器，被其他类操控。自身数据的修改或者操作，尝试以Move Method把那些行为搬移到Data Class中。]]></content>
      <categories>
        <category>Other Tech</category>
      </categories>
      <tags>
        <tag>bad smell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flux Standard Action]]></title>
    <url>%2F2018%2F08%2F29%2Fflux-standard-action%2F</url>
    <content type="text"><![CDATA[含义设计简单、直接、灵活，有一定的标准，容易阅读。 Action要求 是一个js对象 有一个type属性 可能包含error、payload或meta属性 除了以上，不包含其他另外属性。 type是对用户行为进行鉴定和标识，是一个字符串常量，使用===来进行判断。 payload可能是任何类型的值，用来表示action的一部分内容。 error如果action表示错误，可以使用可选属性error，并设置为true。 如果error为true，则payload属性值是一个错误对象。 meta可以是任何类型的值，用于不属于payload的额外信息。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>redux</tag>
        <tag>action</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring集成sonar进行静态代码检测]]></title>
    <url>%2F2018%2F08%2F27%2FSpring%E9%9B%86%E6%88%90sonar%E8%BF%9B%E8%A1%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[前言使用sonar进行静态代码检查，生成相关可视化测试报告，具体效果如下图： 环境 docker ver.18.06.0-ce Mysql ver.5.7.23 Sonarqube 涉及到的知识点 使用docker-compose创建两个container sonar-mysql 用于sonar数据库操作，指定相关端口，镜像文件，环境变量，以及相关操作。 12345678sonar-mysql: image: mysql:5.7.23 volumes: - ./mysql/create_sonar_database.sql:/docker-entrypoint-initdb.d/init.sql ports: - "3308:3306" environment: - MYSQL_ROOT_PASSWORD=password tws-sonar 用于做sonar校验服务器，指定相关端口，镜像文件，和环境变量。 123456789tws-sonar: image: sonarqube ports: - "9000:9000" - "9092:9092" environment: - SONARQUBE_JDBC_USERNAME=root - SONARQUBE_JDBC_PASSWORD=password - SONARQUBE_JDBC_URL=jdbc:mysql://sonar-mysql:3306/sonar?useUnicode=true&amp;characterEncoding=utf8 Spring引入sonar插件 1classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:2.6.2" 1apply plugin: "org.sonarqube" 1apply plugin: "jacoco" jacoco为测试代码覆盖率时需要的插件。 生成报告文档并发送到sonar 1sh './gradlew --info sonarqube' 访问localhost:9000获取相关报告 后记完整项目repo地址：https://github.com/RoyFoo1995/sonar_demo]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>sonar</tag>
        <tag>静态代码检测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot集成Contract以及使用dbrider进行契约测试]]></title>
    <url>%2F2018%2F08%2F27%2Fspringboot-dbrider-contract%E5%A5%91%E7%BA%A6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[SpringBoot集成Contract以及使用dbrider进行契约测试环境 SpringBoot ver.2.0.4.RELEASE rider-spring ver.1.2.11 Java ver.1.8.0_161 相关知识点 SpringBoot集成Contract进行契约测试 添加依赖(版本自选) 1testCompile('org.springframework.cloud:spring-cloud-starter-contract-verifier') 12345dependencyManagement &#123; imports &#123; mavenBom "org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;" &#125;&#125; 1apply plugin: 'spring-cloud-contract' 1classpath "org.springframework.cloud:spring-cloud-contract-gradle-plugin:2.0.0.RC1" 指定testbase类 123contracts &#123; baseClassForTests = 'com.thoughtworks.contractProducer.BaseMvcTest'&#125; 1234567891011121314151617public abstract class BaseMvcTest &#123; @Mock private UserService userService; @Before public void setupController() &#123; RestAssuredMockMvc.standaloneSetup(new UserController(userService)); &#125; @Before public void setUpUserControllerData() &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.add(new User("李四", 12)); users.add(new User("张三", 14)); given(userService.getAll()).willReturn(users); &#125;&#125; contract文件 通常以yml或者groovy编写测试文件: groovy写法 12345678910111213141516171819Contract.make &#123; Map&lt;String, String&gt; userMap = new HashMap&lt;&gt;() userMap.put("name", "张三") userMap.put("role", "test1") userMap.put("name", "李四") userMap.put("role", "test2") request &#123; url("/users") method(HttpMethods.HttpMethod.GET) &#125; response &#123; status(200) body(userMap) &#125;&#125; yml写法 123456789name: "should return users"request: url: /users method: GETresponse: status: 200 bodyFromFile: user.json dbrider测试数据写法 123456789user: - id: 1 name: "张三" role: "test1" password: "123" - id: 2 name: "李四" role: "test2" password: "321" 集成dbrider至contract 1234567891011121314151617@SpringBootTest(classes = ContractProducerApplication.class,webEnvironment = SpringBootTest.WebEnvironment.MOCK)@RunWith(SpringRunner.class)@DBRider@DBUnit(caseSensitiveTableNames = true)@DataSet("simple_users.yml")@ActiveProfiles("test")public abstract class BaseMvcTest &#123; @Autowired private UserController userController; @Before public void setupController() &#123; RestAssuredMockMvc.standaloneSetup(userController); &#125;&#125; 后记项目Demo地址：https://github.com/RoyFoo1995/contractProducer]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>dbrider</tag>
        <tag>contract</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scurm相关概念]]></title>
    <url>%2F2018%2F08%2F23%2FScurm%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[三个角色 Product Owner 产品负责人，清楚的知道产品的愿景，需要对产品待办列表的梳理，优化，优先级排序等负责。决定团队每个冲刺要完成哪些任务。对于团队非常重要，决定Why和What。一般可以对应为现有的产品经理和BA的角色。 Scrum Master Scrum Master是Scrum教练和团队带头人，确保团队合理的运作Scrum，并帮助团队扫除实施中的障碍。 Team 可以认为是开发团队，但是一个跨职能的团队，能够交付一个端到端的真正对客户有价值的产品。 三个工件 产品待办（Product Backlog） 是指产品待办事项的集合，其中事务有优先级判断，先处理优先级高的事项。产品待办列表源自于Scrum方法。在Scrum中，产品主管（Product Owner）收集来自于各方的需要、期望、诉求等等到产品待办列表中，给定优先级；当冲刺计划会议上，团队从产品待办列表中挑选其中事项组成冲刺待办列表。常见的待办事项表达形式是用户故事。 产品冲刺（Spint Backlog） 每个迭代的功能开发列表，PO会根据团队的能力并按照产品待办列表中的优先级来选取每个冲刺要做的事情。团队可以专注在每个迭冲刺要走的事情上而不被打断 增量 Team会将Spint Backlog完成后进行测试，增量即为较上次发布时产品所增加的功能，即是完成的Spint Backlog部分。 燃尽图（Burndown chart，附加概念，不属于3 3 4） 在每个迭代显示剩余工作时间和任务完成情况。 四个会议 计划会议（明确目标，细化任务） 在Sprint计划会议上，需要明确Sprint目标与Sprint BACKLOG，讨论时要考虑团队的接受力，开发的速度、技术水平和商业条件等，提前确定好Sprint交付日期，增量迭代开发任务，产品版本迭代内容等。 每日站会（定点，定时，人齐，会短，高效） 每日进行的Scrum会议是团队交流的形式，固定地点，固定时间点，团队成员都参与，会议维持在15分钟左右，发言内容围绕昨日进度、今日安排、所遇困难三个方面快速的梳理一遍任务面板上的工作内容，所遇困难在会后点对点进行讨论解决。每例会是在Sprint周期内（2-4周）的开发进度反馈，在这个周期内，会经常更新任务面板。 任务面板是“任务状态/工作进程”的二维工作面板，便签颜色可代表团队成员，便签内容代表团队成员所负责的开发任务。任务状态一般可划分为：ToDo，Doing，Tested，Reviewed，Finished五个状态，在一块方形划分区域中贴满了颜色便签，随时更新任务面板状态，保证团队所有成员随时随地都可以了解Sprint周期内的整体开发进度 展示会议（快速反馈） 将完成的产品特性展示给用户验收，并收集用户反馈。 回顾会议（PDCA中CA的部分） Sprint评审回顾会议主要有两个部分的内容，一是做Sprint交付版本与计划版本的验收，二是总结和完善后续Sprint的开发建设。]]></content>
      <categories>
        <category>Agile</category>
      </categories>
      <tags>
        <tag>Scrum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FindBug和PMD插件]]></title>
    <url>%2F2018%2F08%2F22%2FFindBug%E5%92%8CPMD%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言使用Jenkins作为CI、CD工具，以流水线方式运行，需要在构建页面看到FindBug和PMD的分析界面，具体效果如下： 思路 Jenkins下载相关依赖插件 JenkinsFile配置相关插件使用 环境 Jenkins ver.1.121.2 FindBugs Plugin ver.4.72 PMD Plugin ver.3.50 Static Analysis Collector Plug-in ver.1.52 Report Info Plugin ver.1.0 涉及到的知识点 Jenkins插件的下载与安装 点击系统配置，在右边选择管理插件，在可选插件中过滤需要安装的插件，勾选后点击安装。 JenkinsFile配置 12345678910111213stage('Check') &#123; steps &#123; sh "./gradlew findbugsMain" sh "./gradlew pmdMain" sh "./gradlew check -xtest --info" &#125; post &#123; always &#123; step([$class: 'FindBugsPublisher', pattern: '**/findbugs/main.xml', canRunOnFailed : true]) step([$class: 'PmdPublisher', pattern: '**/pmd/main.xml', canRunOnFailed : true]) &#125; &#125;&#125; 在代码中添加了以上配置。 说明： ./gradlew check -xtest —info命令会顺序执行当前项目下所有check相关插件，如checkstyle、findbugs、pmd等，如果前面某个check失败，则会导致build failed，不会生成其他插件的报告信息，所以在之前要执行相关命令或直接分别使用check命令； post执行是跟其位置相关，always属性是代表不管执行steps是否成功都会执行，还有其他success、fail等属性； FindBugsPublisher和PmdPublisher都是触发Jenkins插件的class，这里需要传递生成的报告文档路径，可以是模糊匹配，canRunOnFailed代表失败后时候run该命令； findbugs配置时生成的报告文档只能是xml或者html，插件可分析文档为xml格式，所以需要在build.gradle文件中设置，如下图（ignoreFailures 代表即使出现代码格式错误也可以继续build）： 1234567891011121314151617tasks.withType(FindBugs) &#123; reports &#123; xml.enabled true html.enabled false &#125;&#125;tasks.withType(Pmd) &#123; ignoreFailures = true ruleSetFiles =files("$&#123;project.rootDir&#125;/config/pmd/PmdRuleSets.xml") source 'src/main/java' include '**/*.java' exclude '**/gen/**' reports &#123; xml.enabled = true html.enabled = true &#125;&#125;]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>findbugs</tag>
        <tag>pmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LitePal For Android（替代SQLite传统操作）]]></title>
    <url>%2F2018%2F08%2F21%2FLitePal-For-Android%2F</url>
    <content type="text"><![CDATA[Github地址LitePal配置 引用 jar包引用 litepal-1.6.0.jar litepal-1.6.0-src.jar Gradle引用(非GitHub项目最新版本) 123dependencies &#123; compile &apos;org.litepal.android:core:1.6.0&apos;&#125; xml文件设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;!-- Define the database name of your application. By default each database name should be end with .db. If you didn't name your database end with .db, LitePal would plus the suffix automatically for you. For example: &lt;dbname value="demo" /&gt; --&gt; &lt;dbname value="demo" /&gt; &lt;!-- Define the version of your database. Each time you want to upgrade your database, the version tag would helps. Modify the models you defined in the mapping tag, and just make the version value plus one, the upgrade of database will be processed automatically without concern. For example: &lt;version value="1" /&gt; --&gt; &lt;version value="1" /&gt; &lt;!-- Define your models in the list with mapping tag, LitePal will create tables for each mapping class. The supported fields defined in models will be mapped into columns. For example: &lt;list&gt; &lt;mapping class="com.test.model.Reader" /&gt; &lt;mapping class="com.test.model.Magazine" /&gt; &lt;/list&gt; --&gt; &lt;list&gt; &lt;/list&gt; &lt;!-- Define where the .db file should be. "internal" means the .db file will be stored in the database folder of internal storage which no one can access. "external" means the .db file will be stored in the path to the directory on the primary external storage device where the application can place persistent files it owns which everyone can access. "internal" will act as default. For example: &lt;storage value="external" /&gt; --&gt; &lt;/litepal&gt;&lt;!-- dbname:数据库名字 version：数据库版本号 list：映射模型 storage：配置数据库存储位置，只有internal（内部）和external（外部）两种配置--&gt; 配置litepalApplication 直接在AndroidManifest文件中设置 12345678&lt;manifest&gt; &lt;application android:name="org.litepal.LitePalApplication" ... &gt; ... &lt;/application&gt;&lt;/manifest&gt; 自定义MyApplication 首先在AndroidManifest中指定自定义class 12345678&lt;manifest&gt; &lt;application android:name="com.example.MyOwnApplication" ... &gt; ... &lt;/application&gt;&lt;/manifest&gt; 在代码中自定义MyApplication 123456789public class MyOwnApplication extends AnotherApplication &#123; @Override public void onCreate() &#123; super.onCreate(); LitePal.initialize(this); &#125; ...&#125; 使用 建表 1234567891011121314151617181920212223242526272829public class Album extends DataSupport &#123; //id主键可以不写，默认生成 @Column(unique = true, defaultValue = "unknown")//不允许重复，默认值位unknown private String name; private float price; private byte[] cover; private List&lt;Song&gt; songs = new ArrayList&lt;Song&gt;(); // generated getters and setters. ...&#125;public class Song extends DataSupport &#123; @Column(nullable = false)//允许为null private String name; private int duration; @Column(ignore = true)//允许忽略 private String uselessField; private Album album; // generated getters and setters. ...&#125; 修改litepal.xml文件中的映射 1234&lt;list&gt; &lt;mapping class="org.litepal.litepalsample.model.Album" /&gt; &lt;mapping class="org.litepal.litepalsample.model.Song" /&gt;&lt;/list&gt; 更改表属性 在继承DataSupport的类中修改相关属性后，在xml文件中将数据库版本+1 数据保存 123456789101112131415Album album = new Album();album.setName("album");album.setPrice(10.99f);album.setCover(getCoverImageBytes());album.save();Song song1 = new Song();song1.setName("song1");song1.setDuration(320);song1.setAlbum(album);song1.save();Song song2 = new Song();song2.setName("song2");song2.setDuration(356);song2.setAlbum(album);song2.save(); 数据修改 123Album albumToUpdate = DataSupport.find(Album.class, 1);albumToUpdate.setPrice(20.99f); // raise the pricealbumToUpdate.save(); 或者 123Album albumToUpdate = new Album();albumToUpdate.setPrice(20.99f); // raise the pricealbumToUpdate.update(id); 或者 123Album albumToUpdate = new Album();albumToUpdate.setPrice(20.99f); // raise the pricealbumToUpdate.updateAll(&quot;name = ?&quot;, &quot;album&quot;); 删除数据 1DataSupport.delete(Song.class, id); 或者 1DataSupport.deleteAll(Song.class, &quot;duration &gt; ?&quot; , &quot;350&quot;); 查找数据 1Song song = DataSupport.find(Song.class, id); 或者 1List&lt;Song&gt; allSongs = DataSupport.findAll(Song.class); 或者 1List&lt;Song&gt; songs = DataSupport.where(&quot;name like ?&quot;, &quot;song%&quot;).order(&quot;duration&quot;).find(Song.class); 异步查询 123456DataSupport.findAllAsync(Song.class).listen(new FindMultiCallback() &#123; @Override public &lt;T&gt; void onFinish(List&lt;T&gt; t) &#123; List&lt;Song&gt; allSongs = (List&lt;Song&gt;) t; &#125;&#125;); 支持代码生成数据库 12345LitePalDB litePalDB = new LitePalDB(&quot;demo2&quot;, 1);litePalDB.addClassName(Singer.class.getName());litePalDB.addClassName(Album.class.getName());litePalDB.addClassName(Song.class.getName());LitePal.use(litePalDB); 后记以上总结并不完全，还有很多其他操作没有总结，作者个人CSDN博客更全——作者CSDN]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-小球沿路径移动(Path+PathMeasure+ValueAnimator)实现]]></title>
    <url>%2F2018%2F08%2F21%2FAndroid-%E5%B0%8F%E7%90%83%E6%B2%BF%E8%B7%AF%E5%BE%84%E7%A7%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[前言在项目中遇到了这样一个需求，一个Imageview围绕另一个Imageview沿倾斜的椭圆路径旋转，具体效果如下： 思路 确定椭圆的坐标 用PathMeasure计算移动点的坐标 设置属性动画和差值器 添加属性动画监听 设置视图坐标 环境 API 25 JDK 1.8.0_101 涉及到的知识点 获取控件在屏幕中的绝对坐标 123456789101112//获取控件当前位置int[] startLoc = new int[2];rotateIv.getLocationInWindow(startLoc);//获取被围绕控件的起始点int[] parentStart = new int[2];customIv.getLocationInWindow(parentStart);//获取被围绕坐标的终点int[] parentEnd = new int[2];parentEnd[0] = parentStart[0] + customIv.getWidth();parentEnd[1] = parentStart[1] + customIv.getHeight(); 绘制椭圆并旋转角度 12345678910 //构建椭圆// KLog.i((parentStart[0]-deviation)+" " +(parentStart[1]-deviation)+" "+(parentEnd[0]+deviation)+" "+(parentEnd[1]+deviation)); Path path = new Path(); RectF rectF = new RectF(parentStart[0]-120,parentStart[1]-220,parentEnd[0]+100,parentEnd[1]);//椭圆大小需自己调整 path.addArc(rectF,0,360); //设置椭圆倾斜度数 Matrix matrix = new Matrix(); matrix.setRotate(-14,(parentStart[0]+parentEnd[0])/2,(parentStart[1]+parentEnd[1])/2); path.transform(matrix); 视图加载监听 12345678//添加视图加载完成监听，getLocationInWindow需等到视图加载完成后才能返回正确值，否则为0customIv.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; // TODO Auto-generated method stub startRotate(); &#125;&#125;); 属性动画监听 123456789101112131415161718 //添加监听 valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //获取当前位置 float value = (float) animation.getAnimatedValue(); //传入一个距离distance(0&lt;=distance&lt;=getLength())，然后会计算当前距 // 离的坐标点和切线，pos会自动填充上坐标 pathMeasure.getPosTan(value,mCurrentPosition,null); //打印当前坐标// KLog.i(mCurrentPosition[0]+" "+mCurrentPosition[1]); //设置视图坐标 rotateIv.setX(mCurrentPosition[0]); rotateIv.setY(mCurrentPosition[1]); &#125; &#125;); valueAnimator.start(); 所有代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package cn.edu.neu.providence.activity;import android.animation.ValueAnimator;import android.app.Activity;import android.graphics.Matrix;import android.graphics.Path;import android.graphics.PathMeasure;import android.graphics.RectF;import android.os.Bundle;import android.view.View;import android.view.ViewTreeObserver;import android.view.Window;import android.view.animation.AccelerateDecelerateInterpolator;import android.view.animation.LinearInterpolator;import android.widget.ImageView;import com.socks.library.KLog;import butterknife.BindView;import butterknife.ButterKnife;import cn.edu.neu.providence.R;public class MainActivity extends Activity &#123; @BindView(R.id.rotate_iv) ImageView rotateIv; @BindView(R.id.custom_iv) ImageView customIv; private float[] mCurrentPosition = new float[2]; private PathMeasure pathMeasure; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); ButterKnife.bind(this); //添加视图加载完成监听，getLocationInWindow需等到视图加载完成后才能返回正确值，否则为0 customIv.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; // TODO Auto-generated method stub startRotate(); &#125; &#125;); &#125; @Override protected void onResume() &#123; super.onResume(); &#125; private void startRotate() &#123; //获取控件当前位置 int[] startLoc = new int[2]; rotateIv.getLocationInWindow(startLoc); //获取被围绕控件的起始点 int[] parentStart = new int[2]; customIv.getLocationInWindow(parentStart); //获取被围绕坐标的终点 int[] parentEnd = new int[2]; parentEnd[0] = parentStart[0] + customIv.getWidth(); parentEnd[1] = parentStart[1] + customIv.getHeight(); //构建椭圆// KLog.i((parentStart[0]-deviation)+" " +(parentStart[1]-deviation)+" "+(parentEnd[0]+deviation)+" "+(parentEnd[1]+deviation)); Path path = new Path(); RectF rectF = new RectF(parentStart[0]-120,parentStart[1]-220,parentEnd[0]+100,parentEnd[1]);//椭圆大小需自己调整 path.addArc(rectF,0,360); //设置椭圆倾斜度数 Matrix matrix = new Matrix(); matrix.setRotate(-14,(parentStart[0]+parentEnd[0])/2,(parentStart[1]+parentEnd[1])/2); path.transform(matrix); //pathMeasure用来计算显示坐标 pathMeasure = new PathMeasure(path,true); //属性动画加载 ValueAnimator valueAnimator = ValueAnimator.ofFloat(0,pathMeasure.getLength()); //设置动画时长 valueAnimator.setDuration(10000); //加入差值器 valueAnimator.setInterpolator(new LinearInterpolator()); //设置无限次循环 valueAnimator.setRepeatCount(ValueAnimator.INFINITE); //添加监听 valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //获取当前位置 float value = (float) animation.getAnimatedValue(); //boolean getPosTan(float distance, float[] pos, float[] tan) ： //传入一个距离distance(0&lt;=distance&lt;=getLength())，然后会计算当前距 // 离的坐标点和切线，pos会自动填充上坐标 pathMeasure.getPosTan(value,mCurrentPosition,null); //打印当前坐标// KLog.i(mCurrentPosition[0]+" "+mCurrentPosition[1]); //设置视图坐标 rotateIv.setX(mCurrentPosition[0]); rotateIv.setY(mCurrentPosition[1]); &#125; &#125;); valueAnimator.start(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测验题目整理]]></title>
    <url>%2F2018%2F08%2F21%2F%E6%B5%8B%E9%AA%8C%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[在使用Redux的前提下，从在页面上触发修改到你看到的页面变化，中间发生了什么 Redux首先使用的是观察者模式，将数据统一管理，与React直接调用setState不同的是只有使用了connect方法在数据中心设置了观察者的组件以及其传递了值的子组件才会接收到新的props，从而调用React更新机制。数据的修改是通过dispatch一个action，在reducer中返回新的state对象来修改源数据。 js中this引用为什么会变成undefined，强制绑定this引用的方式有哪几种，分别写出实例代码。 不通过对象调用，直接使用某含有this的方法时会出现this为undefined，强制绑定的方法有call(obj, arg1, arg2)和apply(obj, arg1, arg2)方法。 在使用React时，如何获得某个input的值？ 可以设置某个input的click属性为父组件自定义的方法，如： 123changeTest = (text) =&gt; &#123; console.log(text);&#125;; 12&lt;input onChange=&#123;(event) =&gt; &#123; this.changeTest(event.target.value)&#125;&#125;/&gt; 或 123changeTest = (event) =&gt; &#123; console.log(event.target.value);&#125;; 1&lt;input onChange=&#123;::this.changeTest&#125;/&gt; 常见的需要重构的坏味道有哪些？以及他们的影响？ 代码重复：难以维护，需要修改时要重复修改多处； 方法过长：难以阅读，一个方法做的事情太多，阅读起来比较困难； 较复杂的类：难以理解，一个类需要做很多的事情就会出现很多变量和方法，比较难理解 参数过长：难以使用，一个方法需要的参数较长，使用的时候就需要要多的依赖项； 不名义的变量名：难以理解，当看到某个变量名，应该以名字就知道其意义，而不是简单的当作临时变量随意取名。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React:state vs props]]></title>
    <url>%2F2018%2F08%2F21%2FReact-state-vs-props%2F</url>
    <content type="text"><![CDATA[React : state vs props从功能划分propsprops 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非外部组件主动传入新的 props，否则组件的 props 永远保持不变。 statestate 的主要作用是用于组件保存、控制、修改自己的可变状态。state 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为 state 是一个局部的、只能被组件自身控制的数据源。state 中状态可以通过 this.setState方法进行更新，setState 会导致组件的重新渲染 状态propsprops经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是只读的，不可改变的。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中。 statestate的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防止应用被第三方Kill]]></title>
    <url>%2F2018%2F08%2F21%2F%E9%98%B2%E6%AD%A2%E7%AC%AC%E4%B8%89%E6%96%B9kill%2F</url>
    <content type="text"><![CDATA[关于应用被第三方kill的操作 Service设置成START_STICKY，kill 后会被重启（等待5秒左右），重传Intent，保持与重启前一样。（PM1中提供参考） 通过 startForeground将进程设置为前台进程，做前台服务，优先级和前台应用一个级别，除非在系统内存非常缺，否则此进程不会被 kill 双进程Service：让2个进程互相保护，其中一个Service被清理后，另外没被清理的进程可以立即重启进程 QQ黑科技:在应用退到后台后，另起一个只有 1 像素的页面停留在桌面上，让自己保持前台状态，保护自己不被后台清理工具杀死 在已经root的设备下，修改相应的权限文件，将App伪装成系统级的应用（Android4.0系列的一个漏洞，已经确认可行） Android系统中当前进程(Process)fork出来的子进程，被系统认为是两个不同的进程。当父进程被杀死的时候，子进程仍然可以存活，并不受影响。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
